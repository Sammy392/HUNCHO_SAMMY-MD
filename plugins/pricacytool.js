const fs = require("fs");
const config = require("../config");
const { cmd, commands } = require("../command");
const path = require('path');

cmd({
    pattern: "privacy",
    alias: ["privacymenu"],
    desc: "Privacy settings menu",
    category: "privacy",
    react: "üîê",
    filename: __filename
}, 
async (cmd, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {

        let privacyMenu = `
‚ï≠‚îÅ‚îÅ„Äî *·¥ò Ä…™·¥†·¥Ä·¥Ñ è s·¥á·¥õ·¥õ…™…¥…¢s* „Äï‚îÅ‚îÅ‚îà‚ä∑
‚îá‚Ä¢  ô ü·¥è·¥Ñ·¥ã ü…™s·¥õ - ·¥†…™·¥á·¥°  ô ü·¥è·¥Ñ·¥ã·¥á·¥Ö ·¥ús·¥á Äs
‚îá‚Ä¢ …¢·¥á·¥õ ô…™·¥è - …¢·¥á·¥õ ·¥ús·¥á Ä's  ô…™·¥è
‚îá‚Ä¢ s·¥á·¥õ·¥ò·¥ò·¥Ä ü ü - s·¥á·¥õ ·¥ò Ä·¥è“ì…™ ü·¥á ·¥ò…™·¥Ñ ·¥ò Ä…™·¥†·¥Ä·¥Ñ è
‚îá‚Ä¢ s·¥á·¥õ·¥è…¥ ü…™…¥·¥á - s·¥á·¥õ ·¥è…¥ ü…™…¥·¥á ·¥ò Ä…™·¥†·¥Ä·¥Ñ è
‚îá‚Ä¢ s·¥á·¥õ·¥ò·¥ò - ·¥Ñ ú·¥Ä…¥…¢·¥á  ô·¥è·¥õ's ·¥ò Ä·¥è“ì…™ ü·¥á ·¥ò…™·¥Ñ
‚îá‚Ä¢ s·¥á·¥õ·¥ç è…¥·¥Ä·¥ç·¥á - ·¥Ñ ú·¥Ä…¥…¢·¥á  ô·¥è·¥õ's …¥·¥Ä·¥ç·¥á
‚îá‚Ä¢ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á ô…™·¥è - ·¥Ñ ú·¥Ä…¥…¢·¥á  ô·¥è·¥õ's  ô…™·¥è
‚îá‚Ä¢ …¢ Ä·¥è·¥ú·¥òs·¥ò Ä…™·¥†·¥Ä·¥Ñ è - s·¥á·¥õ …¢ Ä·¥è·¥ú·¥ò ·¥Ä·¥Ö·¥Ö ·¥ò Ä…™·¥†·¥Ä·¥Ñ è
‚îá‚Ä¢ …¢·¥á·¥õ·¥ò Ä…™·¥†·¥Ä·¥Ñ è - ·¥†…™·¥á·¥° ·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ·¥ò Ä…™·¥†·¥Ä·¥Ñ è s·¥á·¥õ·¥õ…™…¥…¢s
‚îá‚Ä¢ …¢·¥á·¥õ·¥ò·¥ò - …¢·¥á·¥õ ·¥ús·¥á Ä's ·¥ò Ä·¥è“ì…™ ü·¥á ·¥ò…™·¥Ñ·¥õ·¥ú Ä·¥á
‚îá
‚îá*·¥è·¥ò·¥õ…™·¥è…¥s “ì·¥è Ä ·¥ò Ä…™·¥†·¥Ä·¥Ñ è ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ös:*
‚îá‚Ä¢ ·¥Ä ü ü - ·¥á·¥†·¥á Ä è·¥è…¥·¥á
‚îá‚Ä¢ ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õs - ·¥ç è ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õs ·¥è…¥ ü è
‚îá‚Ä¢ ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ_ ô ü·¥Ä·¥Ñ·¥ã ü…™s·¥õ - ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õs ·¥áx·¥Ñ·¥á·¥ò·¥õ  ô ü·¥è·¥Ñ·¥ã·¥á·¥Ö
‚îá‚Ä¢ …¥·¥è…¥·¥á - …¥·¥è ô·¥è·¥Ö è
‚îá‚Ä¢ ·¥ç·¥Ä·¥õ·¥Ñ ú_ ü·¥Äs·¥õ_s·¥á·¥á…¥ - ·¥ç·¥Ä·¥õ·¥Ñ ú  ü·¥Äs·¥õ s·¥á·¥á…¥
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà‚ä∑

üìå *Note*: Some commands are owner-only`;

        
        await cmd.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/tbdd5d.jpg` }, // Replace with privacy-themed image if available
                caption: privacyMenu,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363420342566562@newsletter',
                        newsletterName: "popkid",
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.log(e);
        reply(`Error: ${e.message}`);
    }
});

cmd({
    pattern: "blocklist",
    alias: "blacklist",
    desc: "View the list of blocked users.",
    category: "privacy",
    react: "üìã",
    filename: __filename
},
async (cmd, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ You are not the owner!*");

    try {
        // Fetch the block list
        const blockedUsers = await cmd.fetchBlocklist();

        if (blockedUsers.length === 0) {
            return reply("üìã Your block list is empty.");
        }

        // Format the blocked users with üìå and count the total
        const list = blockedUsers
            .map((user, i) => `üö´  ô ü·¥è·¥Ñ·¥ã·¥á·¥Ö ${user.split('@')[0]}`) // Remove domain and add üìå
            .join('\n');

        const count = blockedUsers.length;
        reply(`üìã \`POPKID XTR BLOCKED USERS (${count})\`:\n\n${list}`);
    } catch (err) {
        console.error(err);
        reply(`‚ùå Failed to fetch block list: ${err.message}`);
    }
});

cmd({
    pattern: "getbio",
    desc: "Displays the user's bio.",
    category: "privacy",
    react: "üìã",
    filename: __filename,
}, async (cmd, mek, m, { args, reply }) => {
    try {
        const jid = args[0] || mek.key.remoteJid;
        const about = await cmd.fetchStatus?.(jid);
        if (!about) return reply("No bio found.");
        return reply(`User Bio:\n\n${about.status}`);
    } catch (error) {
        console.error("Error in bio command:", error);
        reply("No bio found.");
    }
});
cmd({
    pattern: "setppall",
    desc: "Update Profile Picture Privacy",
    category: "privacy",
    react: "üîê",
    filename: __filename
}, 
async (cmd, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    
    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];  
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }
        
        await cmd.updateProfilePicturePrivacy(value);
        reply(`‚úÖ Profile picture privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});
cmd({
    pattern: "setonline",
    desc: "Update Online Privacy",
    category: "privacy",
    react: "üîê",
    filename: __filename
}, 
async (cmd, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'match_last_seen'];
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'match_last_seen'.");
        }

        await cmd.updateOnlinePrivacy(value);
        reply(`‚úÖ Online privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});
/*
cmd({
    pattern: "setpp",
    alias: "setdp",
    desc: "Set bot profile picture.",
    category: "privacy",
    react: "üñºÔ∏è",
    filename: __filename
},
async (cmd, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    if (!quoted || !quoted.message.imageMessage) return reply("‚ùå Please reply to an image.");
    try {
        const stream = await downloadContentFromMessage(quoted.message.imageMessage, 'image');
        let buffer = Buffer.from([]);
        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }

        const mediaPath = path.join(__dirname, `${Date.now()}.jpg`);
        fs.writeFileSync(mediaPath, buffer);

        // Update profile picture with the saved file
        await cmd.updateProfilePicture(cmd.user.jid, { url: `file://${mediaPath}` });
        reply("üñºÔ∏è Profile picture updated successfully!");
    } catch (error) {
        console.error("Error updating profile picture:", error);
        reply(`‚ùå Error updating profile picture: ${error.message}`);
    }
});
*/
cmd({
    pattern: "setmyname",
    alias: "setname",
    desc: "Set your WhatsApp display name.",
    category: "privacy",
    react: "‚öôÔ∏è",
    filename: __filename
},
async (cmd, mek, m, { from, isOwner, reply, args }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    // Ensure you have the display name argument
    const displayName = args.join(" ");
    if (!displayName) return reply("‚ùå Please provide a display name.");

    try {
        // Ensure the session is loaded before trying to update
        const { state, saveCreds } = await useMultiFileAuthState('path/to/auth/folder');
        const cmd = makeWASocket({
            auth: state,
            printQRInTerminal: true,
        });

        cmd.ev.on('creds.update', saveCreds);

        // Update display name after connection
        await cmd.updateProfileName(displayName);
        reply(`‚úÖ Your display name has been set to: ${displayName}`);
    } catch (err) {
        console.error(err);
        reply("‚ùå Failed to set your display name.");
    }
});

cmd({
    pattern: "updatebio",
    alias: "setbio",
    react: "ü•è",
    desc: "Change the Bot number Bio.",
    category: "privacy",
    use: '.updatebio',
    filename: __filename
},
async (cmd, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return reply('üö´ *You must be an Owner to use this command*');
        if (!q) return reply('‚ùì *Enter the New Bio*');
        if (q.length > 139) return reply('‚ùó *Sorry! Character limit exceeded*');
        await cmd.updateProfileStatus(q);
        await cmd.sendMessage(from, { text: "‚úîÔ∏è *New Bio Added Successfully*" }, { quoted: mek });
    } catch (e) {
        reply('üö´ *An error occurred!*\n\n' + e);
        l(e);
    }
});
cmd({
    pattern: "groupsprivacy",
    desc: "Update Group Add Privacy",
    category: "privacy",
    react: "üîê",
    filename: __filename
}, 
async (cmd, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }

        await cmd.updateGroupsAddPrivacy(value);
        reply(`‚úÖ Group add privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
  pattern: "getprivacy",
  desc: "Get current privacy settings.",
  category: "owner",
  filename: __filename
}, async (cmd, mek, m, { isOwner, reply }) => {
  if (!isOwner) return reply("‚ùå Owner-only command!");
  try {
    const p = await cmd.fetchPrivacySettings?.(true);
    const msg = `üîê *Privacy Settings:*

üì∂ Read Receipts: ${p.readreceipts}
üñºÔ∏è Profile Pic: ${p.profile}
üì± Status: ${p.status}
üåê Online: ${p.online}
üïí Last Seen: ${p.last}
üë• Group Add: ${p.groupadd}
üìû Call: ${p.calladd}`;
    reply(msg);
  } catch (e) {
    reply(`‚ùå Failed to get privacy settings: ${e.message}`);
  }
});

// üñºÔ∏è Get Profile Picture

    
